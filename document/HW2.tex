\documentclass[12pt]{article}
\usepackage{graphicx,import}
\usepackage[svgnames]{xcolor} 
\usepackage{fancyhdr}
\usepackage{subfig}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage[many]{tcolorbox}
\usepackage{listings}
\usepackage{physics}
\usepackage{amsmath}
\usepackage{tikz}
\usepackage{mathdots}
\usepackage{yhmath}
\usepackage{cancel}
\usepackage{color}
\usepackage{siunitx}
\usepackage{array}
\usepackage{multirow}
\usepackage{amssymb}
\usepackage{gensymb}
\usepackage{tabularx}
\usepackage{extarrows}
\usepackage{booktabs}
\usetikzlibrary{fadings}
\usetikzlibrary{patterns}
\usetikzlibrary{shadows.blur}
\usetikzlibrary{shapes}

\usepackage[a4paper, total={6in, 8in} , bottom = 25mm , top = 25mm, headheight = 1.25cm , includehead,includefoot,heightrounded ]{geometry}
\usepackage{afterpage}
\usepackage{amssymb}
\usepackage{pdflscape}
\usepackage{gensymb}
\usepackage{textcomp}
\usepackage{tikz,pgfplots}
\usepackage{xecolor}
\usepackage{rotating}
\usepackage{pdfpages}
\usepackage[T1]{fontenc}
\usepackage{tikz}
\usepackage[utf8]{inputenc}
\usepackage{PTSerif} 
\usepackage{seqsplit}
\usepackage{fancyvrb}
\usepackage{mips}
\usepackage{multirow}
\usepackage{hhline}
\usepackage[edges]{forest}
\usepackage{tabularx}
\usepackage{float}
\usepackage{graphicx}
\usepackage{cprotect}
\usepackage{url}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{pifont}
\newcommand{\xmark}{\ding{55}}%
\def\checkmark{\tikz\fill[scale=0.4](0,.35) -- (.25,0) -- (1,.7) -- (.25,.15) -- cycle;}

\hypersetup{
	colorlinks   = true, %Colours links instead of ugly boxes
	urlcolor     = blue, %Colour for external hyperlinks
	linkcolor    = blue, %Colour of internal links
	citecolor   = red %Colour of citations
}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}

\NewDocumentCommand{\codeword}{v}{
	\texttt{\textcolor{blue}{#1}}
}
\lstset{language=java,keywordstyle={\bfseries \color{blue}}}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}



\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\normalsize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}

\lstdefinestyle{CStyle}{
	backgroundcolor=\color{backgroundColour},   
	commentstyle=\color{mGreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{mGray},
	stringstyle=\color{mPurple},
	basicstyle=\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2,
	language=C
}



\lstset{ %
	language=[mips]Assembler,       % the language of the code
	basicstyle=\footnotesize,       % the size of the fonts that are used for the code
	numbers=left,                   % where to put the line-numbers
	numberstyle=\tiny\color{gray},  % the style that is used for the line-numbers
	stepnumber=1,                   % the step between two line-numbers. If it's 1, each line
	% will be numbered
	numbersep=5pt,                  % how far the line-numbers are from the code
	backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
	showspaces=false,               % show spaces adding particular underscores
	showstringspaces=false,         % underline spaces within strings
	showtabs=false,                 % show tabs within strings adding particular underscores
	frame=single,                   % adds a frame around the code
	rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
	tabsize=4,                      % sets default tabsize to 2 spaces
	breaklines=true,                % sets automatic line breaking
	breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
	% also try caption instead of title
	keywordstyle=\color{blue},          % keyword style
	commentstyle=\color{dkgreen},       % comment style
	stringstyle=\color{mauve},         % string literal style
	escapeinside={\%*}{*)},            % if you want to add a comment within your code
	morekeywords={*,...}               % if you want to add more keywords to the set
}

\setmainfont[ExternalLocation=fonts/]{EBGaramond-Regular.ttf}




\newenvironment{changemargin}[2]{%
	\begin{list}{}{%
			\setlength{\topsep}{0pt}%
			\setlength{\leftmargin}{#1}%
			\setlength{\rightmargin}{#2}%
			\setlength{\listparindent}{\parindent}%
			\setlength{\itemindent}{\parindent}%
			\setlength{\parsep}{\parskip}%
		}%
		\item[]}{\end{list}}


\definecolor{foldercolor}{RGB}{124,166,198}

\tikzset{pics/folder/.style={code={%
			\node[inner sep=0pt, minimum size=#1](-foldericon){};
			\node[folder style, inner sep=0pt, minimum width=0.3*#1, minimum height=0.6*#1, above right, xshift=0.05*#1] at (-foldericon.west){};
			\node[folder style, inner sep=0pt, minimum size=#1] at (-foldericon.center){};}
	},
	pics/folder/.default={20pt},
	folder style/.style={draw=foldercolor!80!black,top color=foldercolor!40,bottom color=foldercolor}
}

\forestset{is file/.style={edge path'/.expanded={%
			([xshift=\forestregister{folder indent}]!u.parent anchor) |- (.child anchor)},
		inner sep=1pt},
	this folder size/.style={edge path'/.expanded={%
			([xshift=\forestregister{folder indent}]!u.parent anchor) |- (.child anchor) pic[solid]{folder=#1}}, inner xsep=0.6*#1},
	folder tree indent/.style={before computing xy={l=#1}},
	folder icons/.style={folder, this folder size=#1, folder tree indent=3*#1},
	folder icons/.default={12pt},
}

\begin{document}
	
	
%%% title pages
\begin{titlepage}
	\begin{center}
		
		\vspace*{0.7cm}
		
		\includegraphics[width=0.4\textwidth]{sharif1.png}\\
		\vspace{0.5cm}
		\textbf{ \Huge{Natural Language Processing} }\\
		\vspace{0.5cm}
		\textbf{ \Large{ Assignment Two} }
		\vspace{0.2cm}
		
		
		\large   Sharif University of Technology\\\vspace{0.2cm}
		\large   Spring 2024 \\\vspace{0.2cm}
		\noindent\rule[1ex]{\linewidth}{1pt}
		Lecturer:\\
		\textbf{{Dr. Asgari}}
		
		
		\vspace{0.15cm}
		Name - Student Number:\\
		
		
		\textbf{{Amirmahdi Namjoo - 402211467}}\\
		\textbf{{Amirmohammad Fakhimi Namjoo - 97107212}}\\
		\textbf{{Illia Hashemi Rad - 97107212}}		
	\end{center}
\end{titlepage}
%%% title pages


%%% header of pages
\newpage
\pagestyle{fancy}
\fancyhf{}
\fancyfoot{}
\cfoot{\thepage}
\chead{NLP}
\rhead{\includegraphics[width=0.1\textwidth]{sharif.png}}
\lhead{Assignment Two}
%%% header of pages



\section{Introduction}

In this project, we have implemented a regex-based text classifier and integrated it with OSPDroid. This system consists of multiple parts. The first part is designed to recognize widely used terms like Email, Phone Number, Address, etc. The second part is a system that gets user-defined regexes and then uses them to find different terms in the input text. This part uses a database system to store all the regexes users give. The last part is a genetic algorithm-based system to extract regex based on the examples given.

We will analyze each part in the next sections.

\section{Main Regex Classifiers}

In the first part, we have a system that detects emails, phone numbers, addresses, and long and short text based on Python features and regexes. This part is implemented in \verb*|main_regexes| directory.

The most important file in this directory is \verb*|extractor.py|. It consists of some utility functions alongside one important method \verb*|Extractor|:



\begin{lstlisting}[language=python]
def Extractor(input_text, char_threshold):
	landlineList = flatten_list([getLandlineNumbers(target) for target in input_text])
	mobileList = flatten_list([getMobiles(target) for target in input_text])
	emailList = flatten_list([EmailExtractor(target) for target in input_text])
	addressList = flatten_list([AddressExtractor(target) for target in input_text])

	output = {
		"phone": {"land": landlineList, "cell": mobileList},
		"email": emailList,
		"addresses": addressList,
		"classification": MessageClassifier(input_text, char_threshold)
}
	return output
\end{lstlisting}

This function runs multiple functions that each have a specific regex on each line of code to find all the matches. The \verb*|char_threshold| is used to determine the boundary between short and long text.  They are all then assembled into a dictionary.


\section{User Defined Regexes}

We used the SQLite3 database alongside the SQLalchemy package to store and use user-defined regexes in this part. This part's code is in the \verb*|database| directory. 

At first, we define the database entity schema using the following code:

\begin{lstlisting}[language=python]
class MessagePattern(Base):
__tablename__ = 'message_patterns'
	id = Column(Integer, primary_key=True)
	name = Column(String, unique=True)
	regex = Column(String)
\end{lstlisting}


After that, we have two important functions, \verb*|add_regex| and \verb*|check_message_patterns|. The first one gets a name and regex as input, then adds that regex associated with that title to the database. It will also not allow duplicate titles and check uniqueness constraints. The latter runs a for loop on all patterns in the database and checks whether they match parts of the function input or not.

\section{Genetic Algorithm}

For the regex extractor part of this project, we used genetic algorithms. Our main source for this part is from the paper we found in this GitHub repository: \url{https://github.com/maojui/Regex-Generator}.

The first part of the algorithm uses a preprocessor to extract all common sub-strings. Note that it does not just find the longest common sub-strings but uses a dynamic programming approach to find all common substrings. It then splits the string bases on these substrings. As this split could be done in different ways, it uses the way with the similarities between splits of each string.

After this preprocessing part, we define our genes based on widely used regex patterns. for example \verb*|\d| is corresponed to \verb*|0x0| genotype and \verb*|[A-Za-z]| is corresponded to \verb*|0x3|.  We modified the original code to add Persian language support.

With this definition, we encode our string into a phenotype by using our rules for genes. After that, we do some preprocessing sections to make the length of all phenotypes the same so they can be used in genetic algorithms. After that, we use typical genetic algorithms like substitution, crossover, and mutation to find the best match.

Our fitness function considers different parameters. The first and most important one is matching. The regex should match all the strings perfectly. If it does not match with one of the strings, it will get a score of minus infinity. Another factor is length, as we want to get short regexes. We will assign different penalties for using each gene. Broad-matching genes like "dot" are punished more harshly than specific genes.

With this in mind, we run different iterations of the genetic algorithm to get a reasonable result for our regex that matches all our strings.

The code is included in \verb*|regex_generator| directory and consists of multiple files. The important ones include:

\begin{enumerate}
\item \verb*|decoder.py|: This file is used to decode strings into phenotypes.

\item \verb*|evaluate.py|: This file includes functions that calculate fitness scores based on given regex/

\item \verb*|generator.py|: This file is the runner part of the algorithm that initiates the initial population and then runs the genetic algorithm.

\item \verb*|genetic.py|: This file include the main functions for genetic algorithm. Functions like mutation and crossover all reside in this file.

\item \verb*|parser.py|: This file includes the preprocessor part of our system that finds common substrings and does the string splitting based on these common substrings.

\end{enumerate}





\newpage




\end{document}



